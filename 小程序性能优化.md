## 小程序性能优化

### 原生部分

- 首先需要了解一下小程序从打开到页面出现发生了什么。
  * 过程
    1. 运行环境加载。（由微信自身预加载）
    2. 下载代码包。
    3. 业务代码注入和渲染。
    4. 异步数据加载。
- 优化思路
  1. 提高加载性能。
    * 控制包的大小。基本上可以说，1M的代码包，下载耗时1秒左右。
      1. 压缩代码，清理无用代码。
      2. 图片使用`cdn`服务器托管，减少包的大小并提高请求速度。
      3. 采用分包策略。首屏单独一个包，其它分包在首屏出现后进行预加载。
  2. 提高渲染性能。
    * 优化`setData`操作，每一次的`setData`都会导致逻辑层向渲染层进行一次通讯，该次通讯会通过`native`层进行中转，所以开销比较大。具体的优化方式如下:
      1. 减少`setData`的数据量，比如与视图没有产生关联的数据可以不使用`setData`。
      2. 合并多次的`setData`请求，减少通讯次数。
      3. 列表更新数据采用局部更新，不要一整个列表一下都更新，只更新有变化的单条。
    * 避免后台页面的`js`占用内存。比如从一个`webview`进入另一个，该`webview`中的定时器不会自动销毁，会继续在后台占用内存。所以最好这种定时器或者持续请求的部分，在切换`webview`时手动进行销毁。
    * 慎用`onPageScroll`事件，该事件也是一次通讯，是`webview`层向`js`逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的`setData`的话，性能就会很差了。
    * 尽可能的使用小程序组件。自定义组件的更新只在组件内部进行，不受页面其他部分内容的影响。
    * 过长的列表，采用滚动的懒加载。微信提供了`IntersectionObserver`对象，`IntersectionObserver`对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。可以通过该对象实现懒加载。
      ```html
      let data = list;
      <img class="img-{{index}}" wx:for="{{data}}"></img>
      data.forEach((item,index)=>{    
      this.
      createIntersectionObserver().
      relativeToViewport.
      observe(`.img-${index}`,res=>
      {        
        if (res.intersectionRatio > 0){            
        this.setData({                
        item.imgShow:true            
        })        
        }    
      })})
      ```
    * 列表中，一定记得给一个相关的`key`值。当数据改变触发渲染层重新渲染的时候，会校正带有`key`的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。`key`值如果不指明，默认会按数组的索引来处理，因而会导致一些类似`input`等输入框组件的值出现混乱的问题。
  3. 首屏优化
    * 提前请求。数据请求并不依赖页面结构完整，可以在页面加载时或代码注入时即 在页面 `onload` 就发起，而不需要等待页面渲染完成。用户等待请求返回的时间就会进一步缩短。
    * 利用缓存。利用`storage API` 对请求结果请进缓存，二次启动时，直接用缓存数据完成渲染，然后再在后台进行据更新，保证用户第一时间看到页面内容，同时，即使在无网环境下，用户也可以使用小程序的部分功能。
    * 避免白屏。请求过程中，在页面中先展示一个基础的骨架和结合已有的数据进行展示，可以让用户对页面内容有一个心理预期，减少在等待的时候离开的可能。
    * 及时反馈。对于一些耗时的操作，在用户等待的过程中，即使给予交互操作的反馈，避免用户以为小程序无响应。

### web-view

- 由于`web-view`其实嵌入的就是`h5`网页，相关的优化都在之前的移动端页面优化中基本都提到了，所以就只提几点优化建议。
- 优化思路
  * 减少嵌入的`h5`页面中的代码阻塞，如存在非顺序关系的接口，可以进行同时异步请求，而不要去阻塞网页的正常渲染。即使需要多个接口的都返回数据后才能正常渲染也可以采用`promise.all()`的方式异步加载。
  * 最好在预计接口可能比较长的地方添加交互提醒。
  * 减少首次加载时的接口请求次数，与渲染无关的接口可以等到页面渲染完成后再进行请求。
  * 减少`web-view`链接的网页的体积，提高容器去加载页面的速度。
